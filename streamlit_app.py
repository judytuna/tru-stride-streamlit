import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import tempfile
import os
import json
import re
from supabase import create_client, Client

# Initialize Supabase client
@st.cache_resource
def init_supabase():
    url = os.getenv("SUPABASE_URL")
    key = os.getenv("SUPABASE_ANON_KEY")

    if not url or not key:
        st.error("Missing Supabase credentials. Please set SUPABASE_URL and SUPABASE_ANON_KEY in your secrets.")
        st.stop()

    return create_client(url, key)

# Supabase database functions

def init_supabase_tables():
    """
    Ensure required tables exist in Supabase
    Note: In production, you'd run this SQL in Supabase dashboard:

    -- Profiles table (extends Supabase auth.users)
    CREATE TABLE profiles (
        id UUID REFERENCES auth.users ON DELETE CASCADE,
        username TEXT UNIQUE,
        is_admin BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id)
    );

    -- Videos table
    CREATE TABLE videos (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id UUID REFERENCES auth.users ON DELETE CASCADE,
        filename TEXT,
        upload_date TIMESTAMP DEFAULT NOW(),
        analysis_results JSONB
    );

    -- Enable Row Level Security
    ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
    ALTER TABLE videos ENABLE ROW LEVEL SECURITY;

    -- Policies
    CREATE POLICY "Users can read own profile" ON profiles FOR SELECT USING (auth.uid() = id);
    CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
    CREATE POLICY "Users can read own videos" ON videos FOR SELECT USING (auth.uid() = user_id);
    CREATE POLICY "Users can insert own videos" ON videos FOR INSERT WITH CHECK (auth.uid() = user_id);
    CREATE POLICY "Admins can read all" ON profiles FOR SELECT USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND is_admin = TRUE)
    );
    CREATE POLICY "Admins can read all videos" ON videos FOR SELECT USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND is_admin = TRUE)
    );
    """
    pass  # Tables should be created via Supabase dashboard/SQL editor

def get_user_stats():
    """Get user statistics from Supabase"""
    supabase = init_supabase()

    # Total users
    profiles_response = supabase.table('profiles').select('*').execute()
    total_users = len(profiles_response.data) if profiles_response.data else 0

    # Total videos
    videos_response = supabase.table('videos').select('*').execute()
    total_videos = len(videos_response.data) if videos_response.data else 0

    # Videos per user - need to join profiles and videos
    videos_per_user_data = []
    for profile in profiles_response.data:
        user_videos = supabase.table('videos').select('*').eq('user_id', profile['id']).execute()
        video_count = len(user_videos.data) if user_videos.data else 0
        videos_per_user_data.append({
            'username': profile['username'],
            'video_count': video_count,
            'is_admin': profile['is_admin']
        })

    videos_per_user = pd.DataFrame(videos_per_user_data) if videos_per_user_data else pd.DataFrame()

    # Upload trends (last 30 days)
    upload_trends_data = []
    if videos_response.data:
        from collections import defaultdict
        date_counts = defaultdict(int)
        for video in videos_response.data:
            if video['upload_date']:
                date_str = video['upload_date'][:10]
                date_counts[date_str] += 1

        upload_trends_data = [{'date': date, 'uploads': count}
                             for date, count in sorted(date_counts.items(), reverse=True)[:30]]

    upload_trends = pd.DataFrame(upload_trends_data)

    return total_users, total_videos, videos_per_user, upload_trends

def authenticate_user(email, password):
    """
    Authenticate using Supabase Auth
    """
    supabase = init_supabase()

    try:
        response = supabase.auth.sign_in_with_password({
            "email": email,
            "password": password
        })

        if response.user:
            # Get profile info to check admin status
            profile_response = supabase.table('profiles').select('*').eq('id', response.user.id).execute()

            if profile_response.data:
                profile = profile_response.data[0]
                return response.user.id, profile.get('is_admin', False), profile.get('username', email)
            else:
                # Create profile if it doesn't exist
                username = response.user.user_metadata.get('username', email.split('@')[0])
                is_admin = response.user.user_metadata.get('is_admin', False)

                supabase.table('profiles').insert({
                    'id': response.user.id,
                    'username': username,
                    'is_admin': is_admin
                }).execute()

                return response.user.id, is_admin, username
    except Exception as e:
        error_msg = str(e).lower()
        print(f"Auth error: {e}")

        # Check for common unverified email errors
        if "invalid login credentials" in error_msg or "email not confirmed" in error_msg:
            return "email_not_verified", False, None

        return None, False, None

    return None, False, None

def create_user(username, email, password):
    """
    Create a new user account using Supabase Auth
    """
    supabase = init_supabase()

    try:
        # Sign up with Supabase Auth
        response = supabase.auth.sign_up({
            "email": email,
            "password": password,
            "options": {
                "data": {
                    "username": username,
                    "is_admin": False
                }
            }
        })

        if response.user:
            return response.user.id, None
        else:
            return None, "Failed to create account - no user returned"

    except Exception as e:
        error_msg = str(e)
        print(f"User creation error: {error_msg}")
        if "already registered" in error_msg or "already exists" in error_msg:
            return None, "Email already exists"
        return None, f"Error: {error_msg}"

def save_analysis(user_id, filename, analysis_results):
    """Save video analysis results to Supabase"""
    supabase = init_supabase()

    # Convert analysis_results to JSON if it's a string
    if isinstance(analysis_results, str):
        try:
            analysis_results = json.loads(analysis_results.replace("'", '"'))
        except:
            analysis_results = {"raw": analysis_results}

    supabase.table('videos').insert({
        'user_id': user_id,
        'filename': filename,
        'analysis_results': analysis_results
    }).execute()

def get_user_videos(user_id):
    """Get videos for a specific user from Supabase"""
    supabase = init_supabase()

    response = supabase.table('videos').select('*').eq('user_id', user_id).order('upload_date', desc=True).execute()

    if response.data:
        # Convert to DataFrame format expected by the UI
        videos_data = []
        for video in response.data:
            videos_data.append({
                'filename': video['filename'],
                'upload_date': video['upload_date'],
                'analysis_results': json.dumps(video['analysis_results']) if isinstance(video['analysis_results'], dict) else str(video['analysis_results'])
            })
        return pd.DataFrame(videos_data)
    else:
        return pd.DataFrame()

def get_all_users():
    """Get all users with video counts from Supabase"""
    supabase = init_supabase()

    # Get all profiles
    profiles_response = supabase.table('profiles').select('*').order('created_at', desc=True).execute()

    if not profiles_response.data:
        return pd.DataFrame()

    # Get video counts for each user
    users_data = []
    for profile in profiles_response.data:
        videos_response = supabase.table('videos').select('*').eq('user_id', profile['id']).execute()
        video_count = len(videos_response.data) if videos_response.data else 0

        # Get email from auth.users (this requires service role key in production)
        users_data.append({
            'id': profile['id'],
            'username': profile['username'],
            'email': f"{profile['username']}@example.com",  # Placeholder since we can't access auth.users with anon key
            'created_at': profile['created_at'],
            'is_admin': profile['is_admin'],
            'video_count': video_count
        })

    return pd.DataFrame(users_data)

def toggle_admin_status(user_id, make_admin):
    """Toggle admin status for a user in Supabase"""
    supabase = init_supabase()

    supabase.table('profiles').update({
        'is_admin': make_admin
    }).eq('id', user_id).execute()

def analyze_gait(video_file):
    """
    Call your HuggingFace Gradio app for gait analysis
    """
    try:
        from gradio_client import Client

        # Connect to your Gradio space
        client = Client("judytuna/tru-stride-analyzer")

        # Save uploaded file temporarily
        with tempfile.NamedTemporaryFile(delete=False, suffix='.mp4') as tmp_file:
            tmp_file.write(video_file.read())
            tmp_file_path = tmp_file.name

        # Call your Gradio app using the correct endpoint
        # Use gradio_client.handle_file() to properly format the file
        from gradio_client import handle_file

        result = client.predict(
            handle_file(tmp_file_path),
            api_name="/process_video_upload"
        )

        # Clean up temp file
        os.unlink(tmp_file_path)

        # Parse the result from your Gradio app
        # You'll need to adjust this based on what your model returns
        if isinstance(result, tuple):
            # If your Gradio returns multiple outputs
            analysis_text = result[0] if result else "No analysis available"
        else:
            analysis_text = str(result)

        # Parse your actual results into structured format
        analysis = parse_gradio_results(analysis_text)

        return analysis

    except Exception as e:
        st.error(f"Error analyzing video: {str(e)}")
        # Fallback to demo data if API fails
        return {
            "primary_gait": "Analysis Failed",
            "confidence": 0.0,
            "stride_length": 0.0,
            "rhythm_score": 0.0,
            "symmetry_score": 0.0,
            "error": str(e)
        }

def parse_gradio_results(analysis_text):
    """
    Parse the stride analysis results from your Gradio app
    Expected format:
    ‚ö†Ô∏è **Stride Analysis Results**
    **Classification:** ABNORMAL
    **Confidence:** 95%
    **Processing Time:** 2.1 seconds
    **Details:** ...
    **Metrics:**
    - Stride Variability: 0.589
    - Mean Knee Angle: 66.0¬∞
    - Body Length Variation: 0.749
    """
    try:
        # Initialize defaults
        analysis = {
            "primary_gait": "Unknown",
            "confidence": 0.0,
            "stride_variability": 0.0,
            "knee_angle": 0.0,
            "body_length_variation": 0.0,
            "processing_time": 0.0,
            "classification": "Unknown",
            "details": ""
        }

        # Parse the text line by line
        lines = analysis_text.split('\n')

        for line in lines:
            line = line.strip()

            # Extract Classification (NORMAL/ABNORMAL)
            if "**Classification:**" in line:
                classification = line.split("**Classification:**")[-1].strip()
                analysis["classification"] = classification
                # Map to gait terminology for dashboard
                analysis["primary_gait"] = f"Stride: {classification}"

            # Extract Confidence percentage
            elif "**Confidence:**" in line:
                confidence_str = line.split("**Confidence:**")[-1].strip()
                # Remove % symbol and convert to decimal
                confidence_num = re.findall(r'\d+', confidence_str)
                if confidence_num:
                    analysis["confidence"] = float(confidence_num[0]) / 100.0

            # Extract Processing Time
            elif "**Processing Time:**" in line:
                time_str = line.split("**Processing Time:**")[-1].strip()
                time_num = re.findall(r'[\d.]+', time_str)
                if time_num:
                    analysis["processing_time"] = float(time_num[0])

            # Extract Details
            elif "**Details:**" in line:
                details = line.split("**Details:**")[-1].strip()
                analysis["details"] = details

            # Extract Metrics
            elif "Stride Variability:" in line:
                variability = re.findall(r'[\d.]+', line)
                if variability:
                    analysis["stride_variability"] = float(variability[0])

            elif "Mean Knee Angle:" in line:
                angle = re.findall(r'[\d.]+', line)
                if angle:
                    analysis["knee_angle"] = float(angle[0])

            elif "Body Length Variation:" in line:
                variation = re.findall(r'[\d.]+', line)
                if variation:
                    analysis["body_length_variation"] = float(variation[0])

        # Calculate quality scores based on your metrics
        # Lower variability = better rhythm (inverted scale)
        rhythm_score = max(0, 10 - (analysis["stride_variability"] * 10))

        # Body length variation - lower is better (inverted scale)
        symmetry_score = max(0, 10 - (analysis["body_length_variation"] * 10))

        # Use knee angle as stride length approximation (normalize to reasonable range)
        stride_length = analysis["knee_angle"] / 30.0  # Rough conversion

        # Final formatted results
        return {
            "primary_gait": analysis["primary_gait"],
            "confidence": analysis["confidence"],
            "stride_length": round(stride_length, 1),
            "rhythm_score": round(rhythm_score, 1),
            "symmetry_score": round(symmetry_score, 1),
            "classification": analysis["classification"],
            "stride_variability": analysis["stride_variability"],
            "knee_angle": analysis["knee_angle"],
            "body_length_variation": analysis["body_length_variation"],
            "processing_time": analysis["processing_time"],
            "details": analysis["details"]
        }

    except Exception as e:
        return {
            "primary_gait": "Parse Error",
            "confidence": 0.0,
            "stride_length": 0.0,
            "rhythm_score": 0.0,
            "symmetry_score": 0.0,
            "error": f"Parsing failed: {str(e)}",
            "raw_output": analysis_text
        }

# Initialize Supabase tables (run SQL in Supabase dashboard first)
# init_supabase_tables()  # Disabled - tables created manually


# App configuration
st.set_page_config(page_title="Tru-Stride", page_icon="üêé", layout="wide")

# Main app
def main():
    st.title("üêé Tru-Stride")

    # Check for existing Supabase session on page load
    if 'user_id' not in st.session_state:
        try:
            supabase = init_supabase()
            # Try to get current session
            session = supabase.auth.get_session()
            if session and session.user:
                # Restore user session
                profile_response = supabase.table('profiles').select('*').eq('id', session.user.id).execute()
                if profile_response.data:
                    profile = profile_response.data[0]
                    st.session_state.user_id = session.user.id
                    st.session_state.username = profile.get('username', session.user.email)
                    st.session_state.is_admin = profile.get('is_admin', False)
        except:
            pass  # If session check fails, continue with normal auth flow

    # Authentication
    if 'user_id' not in st.session_state:
        st.sidebar.header("üîê Authentication")

        # Toggle between login and signup
        auth_mode = st.sidebar.radio("Choose action:", ["Login", "Sign Up Here"])

        if auth_mode == "Login":
            st.sidebar.subheader("Login")
            email = st.sidebar.text_input("Email", key="login_email")
            password = st.sidebar.text_input("Password", type="password", key="login_password")

            if st.sidebar.button("Login"):
                if email and password:
                    user_id, is_admin, username = authenticate_user(email, password)
                    if user_id and user_id != "email_not_verified":
                        st.session_state.user_id = user_id
                        st.session_state.username = username
                        st.session_state.is_admin = is_admin
                        st.rerun()
                    elif user_id == "email_not_verified":
                        st.sidebar.error("üìß Please check your email and click the verification link before logging in.")
                    else:
                        st.sidebar.error("Invalid email or password")
                else:
                    st.sidebar.error("Please enter email and password")

        else:  # Sign Up
            st.sidebar.subheader("Sign Up Here")
            new_username = st.sidebar.text_input("Choose Username", key="signup_username")
            new_email = st.sidebar.text_input("Email Address", key="signup_email")
            new_password = st.sidebar.text_input("Choose Password", type="password", key="signup_password")
            confirm_password = st.sidebar.text_input("Confirm Password", type="password", key="confirm_password")

            if st.sidebar.button("Sign Up", key="signup_button"):
                if new_username and new_email and new_password and confirm_password:
                    if new_password != confirm_password:
                        st.sidebar.error("Passwords do not match")
                    elif "@" not in new_email or "." not in new_email:
                        st.sidebar.error("Please enter a valid email address")
                    elif len(new_password) < 6:
                        st.sidebar.error("Password must be at least 6 characters")
                    else:
                        # Prevent double submission
                        if 'creating_user' not in st.session_state:
                            st.session_state.creating_user = True

                            try:
                                with st.spinner("Creating account..."):
                                    user_id, error = create_user(new_username, new_email, new_password)
                            except Exception as e:
                                del st.session_state.creating_user
                                st.sidebar.error(f"Connection error: {str(e)}")
                                st.stop()

                            if user_id:
                                # Don't auto-login, just show success message
                                del st.session_state.creating_user
                                st.sidebar.success("Account created! Please check your email to verify your account, then login.")
                                st.rerun()
                            else:
                                del st.session_state.creating_user
                                st.sidebar.error(error)
                        else:
                            st.sidebar.info("Creating account... please wait")
                else:
                    st.sidebar.error("Please fill in all fields")

        # Show login/signup prompt
        st.info("üëÜ Please login or sign up in the sidebar to continue")


        return

    # Sidebar navigation
    st.sidebar.success(f"Logged in as: {st.session_state.username}")
    if st.session_state.get('is_admin', False):
        st.sidebar.info("üëë Admin Access")

    if st.sidebar.button("Logout"):
        for key in ['user_id', 'username', 'is_admin']:
            if key in st.session_state:
                del st.session_state[key]
        st.rerun()

    # Check admin status from database
    is_admin = st.session_state.get('is_admin', False)

    if is_admin:
        tab1, tab2, tab3, tab4 = st.tabs(["üìä Admin Dashboard", "üë• User Management", "üìπ Analyze Video", "üìã My Videos"])
    else:
        tab1, tab2 = st.tabs(["üìπ Analyze Video", "üìã My Videos"])

    # Admin Dashboard (only for admins)
    if is_admin:
        with tab1:
            st.header("Admin Dashboard")

            # Get stats
            total_users, total_videos, videos_per_user, upload_trends = get_user_stats()

            # Key metrics
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Users", total_users)
            with col2:
                st.metric("Total Videos", total_videos)
            with col3:
                avg_videos = total_videos / max(total_users, 1)
                st.metric("Avg Videos/User", f"{avg_videos:.1f}")

            # Charts
            col1, col2 = st.columns(2)

            with col1:
                st.subheader("Videos per User")
                if not videos_per_user.empty:
                    fig = px.bar(videos_per_user,
                               x='username', y='video_count',
                               title="Video Uploads by User")
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("No video data yet")

            with col2:
                st.subheader("Upload Trends (Last 30 Days)")
                if not upload_trends.empty:
                    fig = px.line(upload_trends,
                                x='date', y='uploads',
                                title="Daily Upload Trends")
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("No upload trend data yet")

            # Detailed user table
            st.subheader("User Activity Overview")
            # Add admin indicator to the table
            display_df = videos_per_user.copy()
            display_df['Role'] = display_df['is_admin'].apply(lambda x: 'üëë Admin' if x else 'üë§ User')
            st.dataframe(display_df[['username', 'Role', 'video_count']], use_container_width=True)

        # User Management Tab (Admin only)
        with tab2:
            if is_admin:
                st.header("üë• User Management")

                # Get all users
                all_users = get_all_users()

                if not all_users.empty:
                    st.subheader("All Users")

                    for idx, user in all_users.iterrows():
                        with st.expander(f"{'üëë' if user['is_admin'] else 'üë§'} {user['username']} ({user['video_count']} videos)"):

                            col1, col2 = st.columns([3, 1])

                            with col1:
                                st.write(f"**Email:** {user['email']}")
                                st.write(f"**Joined:** {user['created_at'][:10]}")
                                st.write(f"**Videos:** {user['video_count']}")
                                st.write(f"**Status:** {'üëë Admin' if user['is_admin'] else 'üë§ Regular User'}")

                            with col2:
                                # Don't allow demoting yourself
                                if user['username'] != st.session_state.username:
                                    if user['is_admin']:
                                        if st.button(f"Remove Admin", key=f"demote_{user['id']}"):
                                            toggle_admin_status(user['id'], False)
                                            st.success(f"Removed admin access from {user['username']}")
                                            st.rerun()
                                    else:
                                        if st.button(f"Make Admin", key=f"promote_{user['id']}"):
                                            toggle_admin_status(user['id'], True)
                                            st.success(f"Granted admin access to {user['username']}")
                                            st.rerun()
                                else:
                                    st.info("(You)")

                    # Summary stats
                    admin_count = all_users['is_admin'].sum()
                    regular_count = len(all_users) - admin_count

                    st.subheader("User Summary")
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üëë Admins", admin_count)
                    with col2:
                        st.metric("üë§ Regular Users", regular_count)
                    with col3:
                        st.metric("üìä Total Users", len(all_users))

                else:
                    st.info("No users found")

    # Video Analysis Tab
    analysis_tab = tab3 if is_admin else tab1
    with analysis_tab:
        st.header("Analyze Horse Gait")

        uploaded_file = st.file_uploader(
            "Upload a video of your horse",
            type=['mp4', 'avi', 'mov', 'mkv'],
            help="Upload a clear video showing your horse's gait"
        )

        if uploaded_file is not None:
            # Display video
            st.video(uploaded_file)

            if st.button("Analyze Gait", type="primary"):
                with st.spinner("üîç Analyzing gait patterns with AI model..."):
                    # Reset file pointer to beginning
                    uploaded_file.seek(0)

                    # Analyze the video using your HuggingFace model
                    results = analyze_gait(uploaded_file)

                    if "error" in results:
                        st.error(f"Analysis failed: {results['error']}")
                        st.info("üí° Tip: Make sure your video is clear and shows the horse's full body in motion")
                    else:
                        # Save to database
                        save_analysis(st.session_state.user_id,
                                    uploaded_file.name,
                                    str(results))

                        # Display results
                        st.success("‚úÖ Analysis complete!")

                        col1, col2 = st.columns(2)

                        with col1:
                            st.subheader("üèá Stride Analysis Results")

                            # Classification with color coding
                            classification = results.get("classification", "Unknown")
                            if classification == "NORMAL":
                                st.success(f"**Classification:** {classification}")
                            elif classification == "ABNORMAL":
                                st.error(f"**Classification:** {classification}")
                            else:
                                st.info(f"**Classification:** {classification}")

                            st.metric("Confidence", f"{results['confidence']*100:.0f}%")
                            st.metric("Processing Time", f"{results.get('processing_time', 0):.1f}s")

                            # Show details if available
                            if results.get('details'):
                                st.write(f"**Analysis:** {results['details']}")

                        with col2:
                            st.subheader("üìä Stride Metrics")

                            # Raw stride metrics from your model
                            col2a, col2b = st.columns(2)
                            with col2a:
                                st.metric("Stride Variability", f"{results.get('stride_variability', 0):.3f}")
                                st.metric("Mean Knee Angle", f"{results.get('knee_angle', 0):.1f}¬∞")
                            with col2b:
                                st.metric("Body Length Variation", f"{results.get('body_length_variation', 0):.3f}")
                                st.metric("Derived Stride Length", f"{results['stride_length']}m")

                        # Quality scores section
                        st.subheader("üéØ Quality Scores")
                        col3, col4 = st.columns(2)

                        with col3:
                            st.metric("Rhythm Score", f"{results['rhythm_score']}/10",
                                     help="Based on stride variability (lower variability = higher score)")
                        with col4:
                            st.metric("Symmetry Score", f"{results['symmetry_score']}/10",
                                     help="Based on body length variation (lower variation = higher score)")

                        # Overall score visualization
                        if results['rhythm_score'] > 0 and results['symmetry_score'] > 0:
                            overall_score = (results['rhythm_score'] + results['symmetry_score']) / 2

                            fig = go.Figure(go.Indicator(
                                mode = "gauge+number+delta",
                                value = overall_score,
                                domain = {'x': [0, 1], 'y': [0, 1]},
                                title = {'text': "Overall Stride Quality"},
                                delta = {'reference': 8.0},  # Good score reference
                                gauge = {'axis': {'range': [None, 10]},
                                       'bar': {'color': "darkgreen" if classification == "NORMAL" else "darkred"},
                                       'steps': [
                                           {'range': [0, 5], 'color': "lightgray"},
                                           {'range': [5, 8], 'color': "yellow"},
                                           {'range': [8, 10], 'color': "lightgreen"}],
                                       'threshold': {'line': {'color': "red", 'width': 4},
                                                   'thickness': 0.75, 'value': 7}}))
                            st.plotly_chart(fig, use_container_width=True)

                        # Show raw output for debugging (remove in production)
                        if st.checkbox("Show raw model output (debug)"):
                            st.json(results)

    # My Videos Tab
    videos_tab = tab4 if is_admin else tab2
    with videos_tab:
        st.header("My Video Analysis History")

        user_videos = get_user_videos(st.session_state.user_id)

        if user_videos.empty:
            st.info("No videos uploaded yet. Upload your first video in the 'Analyze Video' tab!")
        else:
            st.write(f"Total videos: {len(user_videos)}")

            for idx, video in user_videos.iterrows():
                with st.expander(f"üìπ {video['filename']} - {video['upload_date'][:16]}"):

                    # Parse results (in real app, store as JSON)
                    try:
                        results = eval(video['analysis_results'])  # Don't use eval in production!

                        col1, col2 = st.columns(2)
                        with col1:
                            st.write("**Results:**")
                            st.write(f"‚Ä¢ Primary Gait: {results['primary_gait']}")
                            st.write(f"‚Ä¢ Confidence: {results['confidence']*100:.0f}%")
                            st.write(f"‚Ä¢ Stride Length: {results['stride_length']}m")

                        with col2:
                            st.write("**Quality Scores:**")
                            st.write(f"‚Ä¢ Rhythm: {results['rhythm_score']}/10")
                            st.write(f"‚Ä¢ Symmetry: {results['symmetry_score']}/10")

                    except:
                        st.write("Error displaying results")

if __name__ == "__main__":
    main()