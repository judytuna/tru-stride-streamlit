import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import tempfile
import os
import json
import re
from supabase import create_client, Client

# Initialize Supabase client (removed cache to fix cross-browser session sharing)
def init_supabase():
    url = os.getenv("SUPABASE_URL")
    key = os.getenv("SUPABASE_ANON_KEY")

    if not url or not key:
        st.error("Missing Supabase credentials. Please set SUPABASE_URL and SUPABASE_ANON_KEY in your secrets.")
        st.stop()

    client = create_client(url, key)
    
    # Restore session using stored tokens
    if 'access_token' in st.session_state and 'refresh_token' in st.session_state:
        try:
            client.auth.set_session(
                st.session_state.access_token, 
                st.session_state.refresh_token
            )
        except Exception as e:
            # Clear invalid tokens
            for key in ['access_token', 'refresh_token', 'supabase_user_id']:
                if key in st.session_state:
                    del st.session_state[key]

    return client

# Supabase database functions

def init_supabase_tables():
    """
    Ensure required tables exist in Supabase
    Note: In production, you'd run this SQL in Supabase dashboard:

    -- Profiles table (extends Supabase auth.users)
    CREATE TABLE profiles (
        id UUID REFERENCES auth.users ON DELETE CASCADE,
        username TEXT UNIQUE,
        is_admin BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id)
    );

    -- Videos table
    CREATE TABLE videos (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id UUID REFERENCES auth.users ON DELETE CASCADE,
        filename TEXT,
        upload_date TIMESTAMP DEFAULT NOW(),
        analysis_results JSONB
    );

    -- Enable Row Level Security
    ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
    ALTER TABLE videos ENABLE ROW LEVEL SECURITY;

    -- Policies
    CREATE POLICY "Users can read own profile" ON profiles FOR SELECT USING (auth.uid() = id);
    CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
    CREATE POLICY "Users can read own videos" ON videos FOR SELECT USING (auth.uid() = user_id);
    CREATE POLICY "Users can insert own videos" ON videos FOR INSERT WITH CHECK (auth.uid() = user_id);
    CREATE POLICY "Admins can read all" ON profiles FOR SELECT USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND is_admin = TRUE)
    );
    CREATE POLICY "Admins can read all videos" ON videos FOR SELECT USING (
        EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND is_admin = TRUE)
    );
    """
    pass  # Tables should be created via Supabase dashboard/SQL editor

def get_user_stats():
    """Get user statistics from Supabase with error handling - Admin function bypasses RLS"""
    try:
        # Initialize Supabase with service role key for admin queries
        service_role_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY")
        if service_role_key:
            # Use service role to bypass RLS for admin dashboard
            url = os.getenv("SUPABASE_URL")
            admin_supabase = create_client(url, service_role_key)
            
            # Total users - bypass RLS
            profiles_response = admin_supabase.table('profiles').select('id,username,is_admin').execute()
            total_users = len(profiles_response.data) if profiles_response.data else 0
            
            # Total videos - bypass RLS  
            videos_response = admin_supabase.table('videos').select('id,user_id,upload_date').execute()
            total_videos = len(videos_response.data) if videos_response.data else 0
        else:
            # Fallback to regular client (RLS-protected)
            st.warning("Service role key not configured - admin dashboard showing limited data")
            supabase = init_supabase()
            
            profiles_response = supabase.table('profiles').select('id,username,is_admin').execute()
            total_users = len(profiles_response.data) if profiles_response.data else 0
            
            videos_response = supabase.table('videos').select('id,user_id,upload_date').execute()
            total_videos = len(videos_response.data) if videos_response.data else 0
        
        # Videos per user - optimize by using the data we already have
        videos_per_user_data = []
        video_counts = {}
        
        # Count videos by user_id
        if videos_response.data:
            for video in videos_response.data:
                user_id = video['user_id']
                video_counts[user_id] = video_counts.get(user_id, 0) + 1
        
        # Match with profiles
        if profiles_response.data:
            for profile in profiles_response.data:
                video_count = video_counts.get(profile['id'], 0)
                videos_per_user_data.append({
                    'username': profile['username'],
                    'video_count': video_count,
                    'is_admin': profile['is_admin']
                })
        
        videos_per_user = pd.DataFrame(videos_per_user_data) if videos_per_user_data else pd.DataFrame()
        
        # Upload trends (last 30 days)
        upload_trends_data = []
        if videos_response.data:
            from collections import defaultdict
            date_counts = defaultdict(int)
            
            # Debug: Let's see what we're getting
            for video in videos_response.data:
                upload_date = video.get('upload_date')
                if upload_date:
                    # Handle both date strings and datetime objects
                    if isinstance(upload_date, str):
                        date_str = upload_date[:10]
                    else:
                        date_str = str(upload_date)[:10]
                    date_counts[date_str] += 1
            
            # Create the trends data
            upload_trends_data = [{'date': date, 'uploads': count}
                                 for date, count in sorted(date_counts.items(), reverse=True)[:30]]
        
        upload_trends = pd.DataFrame(upload_trends_data)
        
        return total_users, total_videos, videos_per_user, upload_trends
        
    except Exception as e:
        st.error(f"Error loading dashboard stats: {str(e)}")
        # Return empty data if there's an error
        return 0, 0, pd.DataFrame(), pd.DataFrame()

def authenticate_user(email, password):
    """
    Authenticate using Supabase Auth
    Returns: (user_id, is_admin, username, error_message)
    """
    supabase = init_supabase()

    try:
        response = supabase.auth.sign_in_with_password({
            "email": email,
            "password": password
        })

        if response.user:
            # Check if email is verified
            if not response.user.email_confirmed_at:
                return None, False, None, "Please check your email and click the verification link before logging in."
            
            # Store session tokens for persistence (instead of session object)
            st.session_state.access_token = response.session.access_token
            st.session_state.refresh_token = response.session.refresh_token  
            st.session_state.supabase_user_id = response.user.id
            
            # Get profile info to check admin status
            profile_response = supabase.table('profiles').select('*').eq('id', response.user.id).execute()

            if profile_response.data:
                profile = profile_response.data[0]
                return response.user.id, profile.get('is_admin', False), profile.get('username', email), None
            else:
                # Create profile if it doesn't exist
                username = response.user.user_metadata.get('username', email.split('@')[0])
                is_admin = response.user.user_metadata.get('is_admin', False)

                supabase.table('profiles').insert({
                    'id': response.user.id,
                    'username': username,
                    'is_admin': is_admin
                }).execute()

                return response.user.id, is_admin, username, None
        else:
            return None, False, None, "Login failed. Please check your credentials."
            
    except Exception as e:
        error_msg = str(e).lower()
        print(f"Auth error: {e}")

        if "invalid login credentials" in error_msg:
            return None, False, None, "Invalid email or password. Please try again."
        elif "email not confirmed" in error_msg:
            return None, False, None, "Please check your email and click the verification link before logging in."
        elif "too many requests" in error_msg:
            return None, False, None, "Too many login attempts. Please wait a moment and try again."
        else:
            return None, False, None, f"Login error: {str(e)}"

def create_user(username, email, password):
    """
    Create a new user account using Supabase Auth
    """
    supabase = init_supabase()

    try:
        # Sign up with Supabase Auth
        response = supabase.auth.sign_up({
            "email": email,
            "password": password,
            "options": {
                "data": {
                    "username": username,
                    "is_admin": False
                }
            }
        })

        if response.user:
            return response.user.id, None
        else:
            return None, "Failed to create account - no user returned"

    except Exception as e:
        error_msg = str(e)
        print(f"User creation error: {error_msg}")
        if "already registered" in error_msg or "already exists" in error_msg:
            return None, "Email already exists"
        return None, f"Error: {error_msg}"

def save_analysis(user_id, filename, analysis_results):
    """Save video analysis results to Supabase"""
    supabase = init_supabase()

    # Convert analysis_results to JSON if it's a string
    if isinstance(analysis_results, str):
        try:
            analysis_results = json.loads(analysis_results.replace("'", '"'))
        except:
            analysis_results = {"raw": analysis_results}

    supabase.table('videos').insert({
        'user_id': user_id,
        'filename': filename,
        'analysis_results': analysis_results
    }).execute()

def get_user_videos(user_id):
    """Get videos for a specific user from Supabase"""
    supabase = init_supabase()

    response = supabase.table('videos').select('*').eq('user_id', user_id).order('upload_date', desc=True).execute()

    if response.data:
        # Convert to DataFrame format expected by the UI
        videos_data = []
        for video in response.data:
            videos_data.append({
                'filename': video['filename'],
                'upload_date': video['upload_date'],
                'analysis_results': json.dumps(video['analysis_results']) if isinstance(video['analysis_results'], dict) else str(video['analysis_results'])
            })
        return pd.DataFrame(videos_data)
    else:
        return pd.DataFrame()

def get_all_users():
    """Get all users with video counts from Supabase with error handling"""
    try:
        supabase = init_supabase()

        # Get all profiles with just the fields we need
        profiles_response = supabase.table('profiles').select('id,username,created_at,is_admin').order('created_at', desc=True).execute()

        if not profiles_response.data:
            return pd.DataFrame()

        # Get all videos at once instead of individual queries
        videos_response = supabase.table('videos').select('id,user_id').execute()
        
        # Count videos by user_id
        video_counts = {}
        if videos_response.data:
            for video in videos_response.data:
                user_id = video['user_id']
                video_counts[user_id] = video_counts.get(user_id, 0) + 1

        # Build user data with video counts
        users_data = []
        for profile in profiles_response.data:
            video_count = video_counts.get(profile['id'], 0)
            
            users_data.append({
                'id': profile['id'],
                'username': profile['username'],
                'email': f"{profile['username']}@example.com",  # Placeholder
                'created_at': profile['created_at'],
                'is_admin': profile['is_admin'],
                'video_count': video_count
            })

        return pd.DataFrame(users_data)
        
    except Exception as e:
        st.error(f"Error loading users: {str(e)}")
        return pd.DataFrame()

def toggle_admin_status(user_id, make_admin):
    """Toggle admin status for a user in Supabase"""
    supabase = init_supabase()

    supabase.table('profiles').update({
        'is_admin': make_admin
    }).eq('id', user_id).execute()

def analyze_gait(video_file):
    """
    Call your HuggingFace Gradio app for gait analysis
    """
    try:
        from gradio_client import Client

        # Connect to your Gradio space
        client = Client("judytuna/tru-stride-analyzer")

        # Save uploaded file temporarily
        with tempfile.NamedTemporaryFile(delete=False, suffix='.mp4') as tmp_file:
            tmp_file.write(video_file.read())
            tmp_file_path = tmp_file.name

        # Call your Gradio app using the correct endpoint
        # Use gradio_client.handle_file() to properly format the file
        from gradio_client import handle_file

        result = client.predict(
            handle_file(tmp_file_path),
            api_name="/process_video_upload"
        )

        # Clean up temp file
        os.unlink(tmp_file_path)

        # Parse the result from your Gradio app
        # You'll need to adjust this based on what your model returns
        if isinstance(result, tuple):
            # If your Gradio returns multiple outputs
            analysis_text = result[0] if result else "No analysis available"
        else:
            analysis_text = str(result)

        # Parse your actual results into structured format
        analysis = parse_gradio_results(analysis_text)

        return analysis

    except Exception as e:
        st.error(f"Error analyzing video: {str(e)}")
        # Fallback to demo data if API fails
        return {
            "primary_gait": "Analysis Failed",
            "confidence": 0.0,
            "stride_length": 0.0,
            "rhythm_score": 0.0,
            "symmetry_score": 0.0,
            "error": str(e)
        }

def parse_gradio_results(analysis_text):
    """
    Parse the stride analysis results from your Gradio app
    Expected format:
    ‚ö†Ô∏è **Stride Analysis Results**
    **Classification:** ABNORMAL
    **Confidence:** 95%
    **Processing Time:** 2.1 seconds
    **Details:** ...
    **Metrics:**
    - Stride Variability: 0.589
    - Mean Knee Angle: 66.0¬∞
    - Body Length Variation: 0.749
    """
    try:
        # Initialize defaults
        analysis = {
            "primary_gait": "Unknown",
            "confidence": 0.0,
            "stride_variability": 0.0,
            "knee_angle": 0.0,
            "body_length_variation": 0.0,
            "processing_time": 0.0,
            "classification": "Unknown",
            "details": ""
        }

        # Parse the text line by line
        lines = analysis_text.split('\n')

        for line in lines:
            line = line.strip()

            # Extract Classification (NORMAL/ABNORMAL)
            if "**Classification:**" in line:
                classification = line.split("**Classification:**")[-1].strip()
                analysis["classification"] = classification
                # Map to gait terminology for dashboard
                analysis["primary_gait"] = f"Stride: {classification}"

            # Extract Confidence percentage
            elif "**Confidence:**" in line:
                confidence_str = line.split("**Confidence:**")[-1].strip()
                # Remove % symbol and convert to decimal
                confidence_num = re.findall(r'\d+', confidence_str)
                if confidence_num:
                    analysis["confidence"] = float(confidence_num[0]) / 100.0

            # Extract Processing Time
            elif "**Processing Time:**" in line:
                time_str = line.split("**Processing Time:**")[-1].strip()
                time_num = re.findall(r'[\d.]+', time_str)
                if time_num:
                    analysis["processing_time"] = float(time_num[0])

            # Extract Details
            elif "**Details:**" in line:
                details = line.split("**Details:**")[-1].strip()
                analysis["details"] = details

            # Extract Metrics
            elif "Stride Variability:" in line:
                variability = re.findall(r'[\d.]+', line)
                if variability:
                    analysis["stride_variability"] = float(variability[0])

            elif "Mean Knee Angle:" in line:
                angle = re.findall(r'[\d.]+', line)
                if angle:
                    analysis["knee_angle"] = float(angle[0])

            elif "Body Length Variation:" in line:
                variation = re.findall(r'[\d.]+', line)
                if variation:
                    analysis["body_length_variation"] = float(variation[0])

        # Calculate quality scores based on your metrics
        # Lower variability = better rhythm (inverted scale)
        rhythm_score = max(0, 10 - (analysis["stride_variability"] * 10))

        # Body length variation - lower is better (inverted scale)
        symmetry_score = max(0, 10 - (analysis["body_length_variation"] * 10))

        # Use knee angle as stride length approximation (normalize to reasonable range)
        stride_length = analysis["knee_angle"] / 30.0  # Rough conversion

        # Final formatted results
        return {
            "primary_gait": analysis["primary_gait"],
            "confidence": analysis["confidence"],
            "stride_length": round(stride_length, 1),
            "rhythm_score": round(rhythm_score, 1),
            "symmetry_score": round(symmetry_score, 1),
            "classification": analysis["classification"],
            "stride_variability": analysis["stride_variability"],
            "knee_angle": analysis["knee_angle"],
            "body_length_variation": analysis["body_length_variation"],
            "processing_time": analysis["processing_time"],
            "details": analysis["details"]
        }

    except Exception as e:
        return {
            "primary_gait": "Parse Error",
            "confidence": 0.0,
            "stride_length": 0.0,
            "rhythm_score": 0.0,
            "symmetry_score": 0.0,
            "error": f"Parsing failed: {str(e)}",
            "raw_output": analysis_text
        }

# Initialize Supabase tables (run SQL in Supabase dashboard first)
# init_supabase_tables()  # Disabled - tables created manually


# App configuration
st.set_page_config(
    page_title="Tru-Stride",
    page_icon="assets/tru-stride-logo.png",  # Use logo as favicon
    layout="wide"
)

# Add Open Graph meta tags for social media previews
st.html("""
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tru-stride.streamlit.app/">
    <meta property="og:title" content="Tru-Stride - AI Horse Gait Analysis">
    <meta property="og:description" content="Horse gait analysis using artificial intelligence. Upload videos of your horse to get detailed stride analysis and performance insights.">
    <meta property="og:image" content="https://tru-stride.streamlit.app/~/+/assets/tru-stride-logo.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://tru-stride.streamlit.app/">
    <meta property="twitter:title" content="Tru-Stride - AI Horse Gait Analysis">
    <meta property="twitter:description" content="Horse gait analysis using artificial intelligence. Upload videos of your horse to get detailed stride analysis and performance insights.">
    <meta property="twitter:image" content="https://tru-stride.streamlit.app/~/+/assets/tru-stride-logo.png">

    <!-- Additional meta tags -->
    <meta name="description" content="Horse gait analysis using artificial intelligence. Upload videos of your horse to get detailed stride analysis and performance insights.">
    <meta name="keywords" content="horse, gait, analysis, AI, artificial intelligence, equine, stride, performance">
    <meta name="author" content="Tru-Stride">
""")

# Custom CSS for logo colors and styling
st.markdown("""
<style>
    /* Custom color scheme based on logo */
    :root {
        --logo-background: #f5f3f0;  /* Light beige from logo background */
        --logo-foreground: #d4af37;  /* Gold color from logo design */
        --logo-accent: #b8860b;      /* Darker gold for accents */
    }

    /* Main background */
    .main .block-container {
        background-color: var(--logo-background);
        padding-top: 2rem;
    }

    /* Sidebar styling */
    .css-1d391kg {
        background-color: var(--logo-background);
    }

    /* Header styling */
    h1 {
        color: var(--logo-accent) !important;
        text-align: center;
        font-weight: 700;
    }

    /* Accent colors for buttons and elements */
    .stButton > button {
        background-color: var(--logo-foreground);
        color: white;
        border: none;
        border-radius: 5px;
    }

    .stButton > button:hover {
        background-color: var(--logo-accent);
    }

    /* Tab styling */
    .stTabs [data-baseweb="tab-list"] {
        background-color: var(--logo-background);
    }

    .stTabs [data-baseweb="tab"] {
        color: var(--logo-accent);
    }

    /* Success/info messages */
    .stSuccess {
        background-color: rgba(212, 175, 55, 0.1);
        border-left: 4px solid var(--logo-foreground);
    }
</style>
""", unsafe_allow_html=True)

# Main app
def main():
    # Add logo to sidebar
    try:
        with st.sidebar:
            st.image("assets/tru-stride-logo.png", width=200)
            st.markdown("---")  # Divider line
    except:
        pass  # If logo file not found, continue without it

    st.title("üêé Tru-Stride")

    # Check for existing session tokens on page load  
    if 'user_id' not in st.session_state and 'supabase_user_id' in st.session_state:
        try:
            supabase = init_supabase()
            # Try to get current session after restoration
            session = supabase.auth.get_session()
            
            if session and session.user:
                # Restore user session from tokens
                profile_response = supabase.table('profiles').select('*').eq('id', session.user.id).execute()
                if profile_response.data:
                    profile = profile_response.data[0]
                    st.session_state.user_id = session.user.id
                    st.session_state.username = profile.get('username', session.user.email)
                    st.session_state.is_admin = profile.get('is_admin', False)
            else:
                # Clear invalid session data
                for key in ['access_token', 'refresh_token', 'supabase_user_id']:
                    if key in st.session_state:
                        del st.session_state[key]
        except Exception as e:
            # Clear invalid session data
            for key in ['access_token', 'refresh_token', 'supabase_user_id']:
                if key in st.session_state:
                    del st.session_state[key]

    # Authentication
    if 'user_id' not in st.session_state:
        st.sidebar.header("üîê Authentication")

        # Toggle between login and signup
        auth_mode = st.sidebar.radio("Choose action:", ["Login", "Sign Up Here"])

        if auth_mode == "Login":
            st.sidebar.subheader("Login")
            
            # Use form to ensure proper state management
            with st.sidebar.form("login_form"):
                email = st.text_input("Email", key="login_email")
                password = st.text_input("Password", type="password", key="login_password")
                login_button = st.form_submit_button("Login")

                if login_button:
                    if email and password:
                        with st.spinner("Logging in..."):
                            user_id, is_admin, username, error = authenticate_user(email, password)
                        
                        if user_id:
                            st.session_state.user_id = user_id
                            st.session_state.username = username
                            st.session_state.is_admin = is_admin
                            st.rerun()
                        else:
                            st.error(f"Login failed - Error: {error}")
                            st.error(f"User ID returned: {user_id}")
                    else:
                        st.error("Please enter email and password")

        else:  # Sign Up
            st.sidebar.subheader("Sign Up Here")
            new_username = st.sidebar.text_input("Choose Username", key="signup_username")
            new_email = st.sidebar.text_input("Email Address", key="signup_email")
            new_password = st.sidebar.text_input("Choose Password", type="password", key="signup_password")
            confirm_password = st.sidebar.text_input("Confirm Password", type="password", key="confirm_password")

            if st.sidebar.button("Sign Up", key="signup_button"):
                if new_username and new_email and new_password and confirm_password:
                    if new_password != confirm_password:
                        st.sidebar.error("Passwords do not match")
                    elif "@" not in new_email or "." not in new_email:
                        st.sidebar.error("Please enter a valid email address")
                    elif len(new_password) < 6:
                        st.sidebar.error("Password must be at least 6 characters")
                    else:
                        # Prevent double submission
                        if 'creating_user' not in st.session_state:
                            st.session_state.creating_user = True

                            try:
                                with st.spinner("Creating account..."):
                                    user_id, error = create_user(new_username, new_email, new_password)
                            except Exception as e:
                                del st.session_state.creating_user
                                st.sidebar.error(f"Connection error: {str(e)}")
                                st.stop()

                            if user_id:
                                # Don't auto-login, just show success message
                                del st.session_state.creating_user
                                st.sidebar.success("Account created! Please check your email to verify your account, then login.")
                                st.rerun()
                            else:
                                del st.session_state.creating_user
                                st.sidebar.error(error)
                        else:
                            st.sidebar.info("Creating account... please wait")
                else:
                    st.sidebar.error("Please fill in all fields")

        # Show login/signup prompt
        st.info("üëÜ Please login or sign up in the sidebar to continue")


        return

    # Sidebar navigation
    st.sidebar.success(f"Logged in as: {st.session_state.username}")
    if st.session_state.get('is_admin', False):
        st.sidebar.info("üëë Admin Access")

    if st.sidebar.button("Logout"):
        # Sign out from Supabase
        try:
            supabase = init_supabase()
            supabase.auth.sign_out()
        except:
            pass  # Continue even if Supabase sign out fails
        
        # Clear all session state including tokens
        for key in ['user_id', 'username', 'is_admin', 'analysis_results', 'analysis_filename', 
                   'access_token', 'refresh_token', 'supabase_user_id']:
            if key in st.session_state:
                del st.session_state[key]
        st.rerun()

    # Check admin status from database
    is_admin = st.session_state.get('is_admin', False)

    if is_admin:
        tab1, tab2, tab3, tab4 = st.tabs(["üìä Admin Dashboard", "üë• User Management", "üìπ Analyze Video", "üìã My Videos"])
    else:
        tab1, tab2 = st.tabs(["üìπ Analyze Video", "üìã My Videos"])

    # Admin Dashboard (only for admins)
    if is_admin:
        with tab1:
            st.header("Admin Dashboard")

            # Get stats
            total_users, total_videos, videos_per_user, upload_trends = get_user_stats()

            # Key metrics
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Users", total_users)
            with col2:
                st.metric("Total Videos", total_videos)
            with col3:
                avg_videos = total_videos / max(total_users, 1)
                st.metric("Avg Videos/User", f"{avg_videos:.1f}")

            # Charts
            col1, col2 = st.columns(2)

            with col1:
                st.subheader("Videos per User")
                if not videos_per_user.empty:
                    fig = px.bar(videos_per_user,
                               x='username', y='video_count',
                               title="Video Uploads by User")
                    # Force integer-only y-axis ticks
                    fig.update_yaxes(dtick=1)
                    st.plotly_chart(fig, width='stretch')
                else:
                    st.info("No video data yet")

            with col2:
                st.subheader("Upload Trends (Last 30 Days)")
                if not upload_trends.empty:
                    # Use scatter plot with lines and markers for better single-point visibility
                    fig = px.line(upload_trends,
                                x='date', y='uploads',
                                title="Daily Upload Trends",
                                markers=True)  # Add markers to show data points
                    
                    # Force integer-only y-axis ticks
                    fig.update_yaxes(dtick=1)
                    
                    # Ensure proper date formatting and spacing
                    fig.update_xaxes(
                        tickmode='linear',
                        dtick="D1"  # Show every day
                    )
                    
                    # Make sure single points are visible
                    fig.update_traces(
                        mode='lines+markers',
                        marker=dict(size=8),
                        line=dict(width=3)
                    )
                    
                    st.plotly_chart(fig, width='stretch')
                else:
                    st.info("No upload trend data yet")

            # Detailed user table
            st.subheader("User Activity Overview")
            # Add admin indicator to the table
            display_df = videos_per_user.copy()
            display_df['Role'] = display_df['is_admin'].apply(lambda x: 'üëë Admin' if x else 'üë§ User')
            st.dataframe(display_df[['username', 'Role', 'video_count']], width='stretch')

        # User Management Tab (Admin only)
        with tab2:
            if is_admin:
                st.header("üë• User Management")

                # Get all users
                all_users = get_all_users()

                if not all_users.empty:
                    st.subheader("All Users")

                    for idx, user in all_users.iterrows():
                        with st.expander(f"{'üëë' if user['is_admin'] else 'üë§'} {user['username']} ({user['video_count']} videos)"):

                            col1, col2 = st.columns([3, 1])

                            with col1:
                                st.write(f"**Email:** {user['email']}")
                                st.write(f"**Joined:** {user['created_at'][:10]}")
                                st.write(f"**Videos:** {user['video_count']}")
                                st.write(f"**Status:** {'üëë Admin' if user['is_admin'] else 'üë§ Regular User'}")

                            with col2:
                                # Don't allow demoting yourself
                                if user['username'] != st.session_state.username:
                                    if user['is_admin']:
                                        if st.button(f"Remove Admin", key=f"demote_{user['id']}"):
                                            toggle_admin_status(user['id'], False)
                                            st.success(f"Removed admin access from {user['username']}")
                                            st.rerun()
                                    else:
                                        if st.button(f"Make Admin", key=f"promote_{user['id']}"):
                                            toggle_admin_status(user['id'], True)
                                            st.success(f"Granted admin access to {user['username']}")
                                            st.rerun()
                                else:
                                    st.info("(You)")

                    # Summary stats
                    admin_count = all_users['is_admin'].sum()
                    regular_count = len(all_users) - admin_count

                    st.subheader("User Summary")
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üëë Admins", admin_count)
                    with col2:
                        st.metric("üë§ Regular Users", regular_count)
                    with col3:
                        st.metric("üìä Total Users", len(all_users))

                else:
                    st.info("No users found")


    # Video Analysis Tab
    analysis_tab = tab3 if is_admin else tab1
    with analysis_tab:
        st.header("Analyze Horse Gait")

        uploaded_file = st.file_uploader(
            "Upload a video of your horse",
            type=['mp4', 'avi', 'mov', 'mkv'],
            help="Upload a clear video showing your horse's gait"
        )

        if uploaded_file is not None:
            # Display video
            st.video(uploaded_file)

            if st.button("Analyze Gait", type="primary"):
                with st.spinner("üîç Analyzing gait patterns with AI model..."):
                    # Reset file pointer to beginning
                    uploaded_file.seek(0)

                    # Analyze the video using your HuggingFace model
                    results = analyze_gait(uploaded_file)

                    if "error" in results:
                        st.error(f"Analysis failed: {results['error']}")
                        st.info("üí° Tip: Make sure your video is clear and shows the horse's full body in motion")
                    else:
                        # Save to database
                        save_analysis(st.session_state.user_id,
                                    uploaded_file.name,
                                    str(results))
                        
                        # Store results in session state so they persist
                        st.session_state.analysis_results = results
                        st.session_state.analysis_filename = uploaded_file.name

        # Display results if they exist in session state
        if 'analysis_results' in st.session_state:
            results = st.session_state.analysis_results
            
            # Display results
            st.success("‚úÖ Analysis complete!")

            col1, col2 = st.columns(2)

            with col1:
                st.subheader("üèá Stride Analysis Results")

                # Classification with color coding
                classification = results.get("classification", "Unknown")
                if classification == "NORMAL":
                    st.success(f"**Classification:** {classification}")
                elif classification == "ABNORMAL":
                    st.error(f"**Classification:** {classification}")
                else:
                    st.info(f"**Classification:** {classification}")

                st.metric("Confidence", f"{results['confidence']*100:.0f}%")
                st.metric("Processing Time", f"{results.get('processing_time', 0):.1f}s")

                # Show details if available
                if results.get('details'):
                    st.write(f"**Analysis:** {results['details']}")

            with col2:
                st.subheader("üìä Stride Metrics")

                # Raw stride metrics from your model
                col2a, col2b = st.columns(2)
                with col2a:
                    st.metric("Stride Variability", f"{results.get('stride_variability', 0):.3f}")
                    st.metric("Mean Knee Angle", f"{results.get('knee_angle', 0):.1f}¬∞")
                with col2b:
                    st.metric("Body Length Variation", f"{results.get('body_length_variation', 0):.3f}")
                    st.metric("Derived Stride Length", f"{results['stride_length']}m")

            # Quality scores section
            st.subheader("üéØ Quality Scores")
            col3, col4 = st.columns(2)

            with col3:
                st.metric("Rhythm Score", f"{results['rhythm_score']}/10",
                         help="Based on stride variability (lower variability = higher score)")
            with col4:
                st.metric("Symmetry Score", f"{results['symmetry_score']}/10",
                         help="Based on body length variation (lower variation = higher score)")

            # Overall score visualization
            if results['rhythm_score'] > 0 and results['symmetry_score'] > 0:
                overall_score = (results['rhythm_score'] + results['symmetry_score']) / 2

                fig = go.Figure(go.Indicator(
                    mode = "gauge+number+delta",
                    value = overall_score,
                    domain = {'x': [0, 1], 'y': [0, 1]},
                    title = {'text': "Overall Stride Quality"},
                    delta = {'reference': 8.0},  # Good score reference
                    gauge = {'axis': {'range': [None, 10]},
                           'bar': {'color': "darkgreen" if classification == "NORMAL" else "darkred"},
                           'steps': [
                               {'range': [0, 5], 'color': "lightgray"},
                               {'range': [5, 8], 'color': "yellow"},
                               {'range': [8, 10], 'color': "lightgreen"}],
                           'threshold': {'line': {'color': "red", 'width': 4},
                                       'thickness': 0.75, 'value': 7}}))
                st.plotly_chart(fig, width='stretch')

            # Show raw output for debugging (remove in production)
            st.markdown("---")  # Divider
            show_raw = st.checkbox("Show raw model output (debug)")
            if show_raw:
                st.subheader("üîß Raw Model Output")
                st.json(results)

    # My Videos Tab
    videos_tab = tab4 if is_admin else tab2
    with videos_tab:
        st.header("My Video Analysis History")

        user_videos = get_user_videos(st.session_state.user_id)

        if user_videos.empty:
            st.info("No videos uploaded yet. Upload your first video in the 'Analyze Video' tab!")
        else:
            st.write(f"Total videos: {len(user_videos)}")

            for idx, video in user_videos.iterrows():
                with st.expander(f"üìπ {video['filename']} - {video['upload_date'][:16]}"):

                    # Parse results (in real app, store as JSON)
                    try:
                        results = eval(video['analysis_results'])  # Don't use eval in production!

                        col1, col2 = st.columns(2)
                        with col1:
                            st.write("**Results:**")
                            st.write(f"‚Ä¢ Primary Gait: {results['primary_gait']}")
                            st.write(f"‚Ä¢ Confidence: {results['confidence']*100:.0f}%")
                            st.write(f"‚Ä¢ Stride Length: {results['stride_length']}m")

                        with col2:
                            st.write("**Quality Scores:**")
                            st.write(f"‚Ä¢ Rhythm: {results['rhythm_score']}/10")
                            st.write(f"‚Ä¢ Symmetry: {results['symmetry_score']}/10")

                    except:
                        st.write("Error displaying results")

if __name__ == "__main__":
    main()